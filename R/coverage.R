#' @title Perform calculating depth of coverage.
#' @description Input a BAM file or files to calculate the total bases
#'   overlapping the region. Sequencing depth of coverage in this region equals
#'   to total bases divide by width of region.
#' @details The input BAM file need a BAM index file (<filename>.bai). The index
#'   file can be generated by \emph{samtools} or other BAM/SAM tools after
#'   sorting. Function will stop if the BAM file lose an index file or its index
#'   file is older than its own.
#'
#'   If \emph{bedFile} is not \code{NULL}, it will be splited unless the
#'   \emph{width} option is also \code{NULL}. If a BED file is not provided,
#'   windows will be created from the whole genome, by default 100,000 bp each
#'   window. Coverage of depth will be calculated by each window. Four required
#'   BED fields are chromosome name, start and end position, id.
#'
#'   It can perform in multithreading with number of threads you input. If the
#'   \emph{thread} is over 1, it will perform in multithreading, default by
#'   single thread. Multithreading uses \code{parLapply()} function in
#'   \pkg{parallel} package and it can run on Linux but not Windows system. And
#'   the \emph{batch} option limits the number of GRanges in a batch to run in a
#'   thread.
#'
#'   The result are coverage files (<filename>.cov) which have five columns
#'   indicating chromosome name, chromosome start, chromosome end , id and depth of
#'   coverage, without a header line.
#' @param bamFiles A character string or vector of the BAM files path.
#' @param bedFile A BED file path.
#' @param outDir A character string of directory to output coverage files
#'   (<filename>.cov). Default is the current folder.
#' @param thread An integer providing the number of thread.
#' @param batch An integer giving how many GRanges are performed in a batch.
#' @param mapq.filter A non-negative integer specifying the minimum mapping
#'   quality to include. BAM reads with mapping qualities less than mapqFilter
#'   are discarded.
#' @export
#' @import IRanges
#' @import GenomicRanges
#' @import S4Vectors
#' @import GenomicAlignments
#' @import Biostrings
#' @importFrom Rsamtools BamFile
#' @author Zhan-Ni Chen
#' ####### Perform calculating depth of coverage #######
performCreateCovFile <- function(bamFiles, bedFile, outDir = NULL, thread = 1, batch = 1000, mapq.filter = 30) {
    if (is.null(outDir)) outDir <- '.'
    if (! file.exists(outDir)) dir.create(outDir)
    outDir <- normalizePath(outDir)
    # check bams
    checkBam(bamFiles)
    genomeseqinfo <- seqinfo(BamFile(bamFiles[1]))

    # Region
    region <- bedtoGRange(bedFile, genomeSeqinfo = genomeseqinfo)

    write('Start to calculating coverage...', stdout())

    # do bams
    for (bam in bamFiles) {
        write(paste0('Perform BAM:\n', bam), stdout())
        id <- getID(bam)
        out <- depthOfRegionMultiCore(region = region, bamPath = bam,
                                      thread = thread, batch = batch, mapq.filter = mapq.filter, tmpDir = outDir)
        writeCovFile(out, path = paste0(outDir, "/",  id, ".cov"))
        write(paste0("Write to path: \n", outDir, "/",  id, ".cov"), stdout())
    }
    write('Done.', stdout())
}

#' @title Calculate depth of coverage in a given region.
#' @description Input a BAM file and a GenomicRanges object of given region,
#'   calculate the total bases overlapping this region. Sequencing depth of
#'   coverage of region equals total bases divide by width of region.
#'
#'   The input BAM file need a BAM index file (<filename>.bai). The index file
#'   can be generated by \emph{samtools} or other BAM/SAM tools after sorting.
#'   Function will stop if the BAM file lose an index file or its index file is
#'   older than its own.
#'
#'   \code{depthOfRegionMultiCore()} can perform in multithreading with number
#'   of threads you input. Multithreading uses \code{parLapply()} function in
#'   \pkg{parallel} package and it can run on Linux but not Windows system. And
#'   the \emph{batch} option limits the number of GRanges in a batch to run in a
#'   thread.
#' @param region a GenomicRanges object.
#' @param bamPath a character string of the BAM file path.
#' @param mapq.filter a non-negative integer specifying the minimum mapping
#'   quality to include. BAM records with mapping qualities less than mapqFilter
#'   are discarded.
#' @param thread an integer providing the number of threads just for
#'   \code{depthOfRegionMultiCore()}.
#' @param batch an integer giving how many GRanges are performed in a batch just
#'   for \code{depthOfRegionMultiCore()}.
#' @param tmpDir a character string of the directory path to write to.
#' @return A GenomicRanges object with a column named depth representing the
#'   sequencing depth of this region.
#' @export
#' @import parallel
#' @import IRanges
#' @import GenomicRanges
#' @import S4Vectors
#' @import GenomicAlignments
#' @importFrom GenomicAlignments start
#' @importFrom GenomicAlignments end
#' @importFrom GenomicAlignments width
#' @importFrom Rsamtools BamFile
#' @importFrom Rsamtools scanBamFlag
#' @importFrom Rsamtools ScanBamParam
#' @author Zhan-Ni Chen
#' ####### Calculate depth of coverage in a given region #######
depthOfRegion <- function(region, bamPath, mapq.filter = 30) {
    if (length(unique(seqnames(region))) == 1) {
        what <- c("mapq", "flag")
        flag <- scanBamFlag(isUnmappedQuery = FALSE, isSecondaryAlignment = FALSE, isDuplicate = FALSE)
        param <- ScanBamParam(which = reduce(region), what = what, flag = flag, mapqFilter = mapq.filter)
        inBam <- readGAlignments(file = bamPath, index = bamPath, param = param)
        binCov <- coverage(IRanges(start = start(inBam), width = width(inBam)))
        binCovView <- Views(binCov, start = start(region), width = width(region))
        totalCov <- viewSums(binCovView, na.rm = TRUE)
        depth <- round(totalCov/width(region), 0)
        bamseqinfo <- seqinfo(BamFile(bamPath))
        return(GRanges(Rle(seqnames(region)), IRanges(start = start(region) , end = end(region)),
                seqinfo = bamseqinfo, depth = depth, id = mcols(region)$id))
    } else {
        mcols(region)$index_id <- seq(1, length(region), 1)
        region_lst <- split(region, seqnames(region))
        out_lst <- lapply(region_lst, function(sub_region) {
            what <- c("mapq", "flag")
            flag <- scanBamFlag(isUnmappedQuery = FALSE, isSecondaryAlignment = FALSE, isDuplicate = FALSE)
            param <- ScanBamParam(which = reduce(sub_region), what = what, flag = flag, mapqFilter = mapq.filter)
            inBam <- readGAlignments(file = bamPath, index = bamPath, param = param)
            binCov <- coverage(IRanges(start = start(inBam), width = width(inBam)))
            binCovView <- Views(binCov, start = start(sub_region), width = width(sub_region))
            totalCov <- viewSums(binCovView, na.rm = TRUE)
            depth <- round(totalCov/width(sub_region), 0)
            bamseqinfo <- seqinfo(BamFile(bamPath))
            GRanges(Rle(seqnames(sub_region)), IRanges(start = start(sub_region) , end = end(sub_region)),
                    seqinfo = bamseqinfo, depth = depth, id = mcols(sub_region)$id, index_id=mcols(sub_region)$index_id)
        })
        out_grlst <- as(out_lst, "GRangesList")
        out_gr <- unlist(out_grlst)
        names(out_gr) <- NULL
        out_dr_1 <- out_gr[order(mcols(out_gr)$index_id)]
        out_gr <-

            GRanges(Rle(seqnames(out_dr_1)), IRanges(start = start(out_dr_1),
                                                     end = end(out_dr_1)),
                    seqinfo = seqinfo(out_dr_1),
                    depth = mcols(out_dr_1)$depth,
                    id = mcols(out_dr_1)$id)
        return(out_gr)
    }
}

#' @rdname depthOfRegion
#' @export
depthOfRegionMultiCore <- function(region, bamPath, thread, batch, mapq.filter = 30, tmpDir = NULL) {
    timestamp <- paste0('depth_', as.character(as.integer(Sys.time())))
    if (is.null(tmpDir)) tmpDir <- '.'
    id <- getID(bamPath)
    tmp <- normalizePath(tmpDir)
    tmp <- paste0(tmp, '/tmp_', id, '_', timestamp)
    if (! file.exists(tmp) ) dir.create(path = tmp)
    batch.index <- IRanges(breakInChunks(totalsize = length(region),  chunksize = batch))
    chunks <- GRangesList()
    for (i in 1:length(batch.index)) {
        chunks[[i]] <- region[start(batch.index)[i]:end(batch.index)[i]]
    }
    if (thread <= 1){
        a <- lapply(chunks, function(gr){
            gr <-  depthOfRegion(gr, bamPath, mapq.filter = mapq.filter)
            save(gr, file = paste0(tmp, "/", id, '_', timestamp, "_",
                                   seqnames(gr)[1], "_", min(start(gr)), "_", max(end(gr)),".Rdata"))
        })
    } else{
        clsp <- makeCluster(thread, type = "FORK", outfile = paste0(tmp, "/log.txt"))
        a <- parLapply(clsp, chunks, function(gr, ...) {
            gr <-  depthOfRegion(gr, bamPath, mapq.filter = mapq.filter)
            save(gr, file = paste0(tmp, "/", id, '_', timestamp, "_",
                                   seqnames(gr)[1], "_", min(start(gr)), "_", max(end(gr)),".Rdata"))
         })
        stopCluster(clsp)
    }
    allrdata <- list.files(path = tmp, pattern = ".Rdata", all.files = TRUE,
                           full.names = TRUE, recursive = FALSE, include.dirs = FALSE)
    result <- GRangesList()
    for (i in 1:length(allrdata)) {
        gr <- get(load(allrdata[i]))
        result[[i]] <- gr
    }
    unlink(tmp, recursive = TRUE)
    unlist(result)
}

#' @title Merge coverage files.
#' @description Align and merge coverage files (<filename>.cov) with chromosome,
#'   start and end position. Five required fields in a coverage file are
#'   chromosome name, start and end position, id and depth of coverage.
#' @param x A character vector contains several coverage files path.
#' @param path Path to write to.
#' @return A data frame, of which columns are chromosome, start position, end
#'   position, id and depths in input coverage files.
#' @export
#' @importFrom utils read.table
#' @importFrom utils write.table
#' @importFrom data.table data.table
#' @author Zhan-Ni Chen
#' ####### Merge coverage files #######
mergerCovFiles <- function(x, path = NULL) {
    if (is.null(path)) path <- 'mergedCov.txt'

    write('Start to merge coverage files...', stdout())

    coverageMatrix <- NULL
    for (i in x) {
        id <- getID(i)
        indat <- read.table(i, header = FALSE, sep = "\t", quote = "", comment.char = "#",
                            na.strings = "NA", fill = TRUE, stringsAsFactors = FALSE)
        colnames(indat) <- c("chr", "start", "end", 'id', id)
        indat2 <- data.table(indat, key = "id")
        if (is.null(coverageMatrix)) {
            coverageMatrix <- indat
        } else {
            coverageMatrix <- merge(coverageMatrix, indat[,c('id', id)], by = "id", all=TRUE)
        }
    }
    coverageMatrix$chr <- factor(coverageMatrix$chr,
                                 levels = c(as.character(seq(1, 22, 1)), 'X', 'Y'))
    coverageMatrix <- coverageMatrix[, c('chr', 'start', 'end', 'id',
                setdiff(colnames(coverageMatrix), c('chr', 'start', 'end', 'id')))]
    write.table(coverageMatrix[with(coverageMatrix,
                order(coverageMatrix$chr, coverageMatrix$start, coverageMatrix$end)), ],
                file = path, row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")

    write(paste0("Write to path: \n", normalizePath(path)), stdout())
}
